<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <h1 id="1-overview"><strong>1. Overview</strong></h1> <p>During user mode program execution, unexpected events, exceptions or interruptions, may occur, leading to a trap. This post’s goal is to provide a general view of how the trap is handled, and this section will provide an outline of key concepts. You can skip forward to the next section if you’d rather start with something practical.</p> <h2 id="11-trap">1.1. Trap</h2> <blockquote> <p>The transfer of control to a trap handler caused by either an exception or an interrupt. —- RISC-V Spec Volume 2^[1]</p> </blockquote> <p>Any control transfer raised from unprivileged mode (ie. user/application mode) to the operating system can be considered as a trap.</p> <table> <thead> <tr> <th>Type</th> <th>Detailed Description</th> <th>Execution terminates?</th> <th>Software is oblivious?</th> <th>Handled by environment?</th> </tr> </thead> <tbody> <tr> <td>Contained Trap</td> <td>Being visible and handled by the software in the environment</td> <td>No</td> <td>No</td> <td>No</td> </tr> <tr> <td>Requested Trap</td> <td>Synchronous action request from software to the environment (<em>eg. System call which removes the hart</em>)</td> <td>Maybe (when termination is requested)</td> <td>No</td> <td>Yes</td> </tr> <tr> <td>Invisible Trap</td> <td>Handled transparently by the execution environment and execution resumes normally after the trap is handled (<em>eg.handling device interrupts</em>)</td> <td>No</td> <td>Yes</td> <td>Yes</td> </tr> <tr> <td>Fatal Trap</td> <td>fatal failure and causes the execution environment to terminate execution</td> <td>Yes</td> <td>Maybe</td> <td>Yes</td> </tr> </tbody> </table> <h2 id="12-exception-and-interrupt">1.2. Exception and Interrupt</h2> <p>Exception: Asynchronous, program-initiated unexpected events raised within the processor (associated with instructions) which disrupt program execution. <em>e.g. Divide by zero, Undefined function</em></p> <p>Interrupt: Asynchronous, device-initiated events from user to the OS. Most interrupts are external while there are still a few internal interrupts under RISC-V architecture. <em>e.g. Clock tick, network packet</em></p> <p>Interrupts and exceptions are <strong>precise</strong> when it is clearly associated with specific instructions^[2]. Therefore, all instructions before the faulty instructions could be completely executed with the faulty instruction address stored in SEPC/MEPC (will be elaborated in 2. RISC-V Implementation). <strong>Imprecise</strong> interrupts and exceptions are not associated with instructions, the faulty instruction will be determined by operating system. Consequently, The address stored in SEPC/MEPC is from the latest instruction in the pipeline.</p> <h1 id="2-trap-handling-implementation"><strong>2. Trap Handling Implementation</strong></h1> <h2 id="21-csr---controlstatus-register">2.1. CSR - Control/Status Register</h2> <p>To assist the trap handling, a subset of CSRs is utilized to record the trap-related information <em>(e.g. The cause of trap)</em>. In this section, CSRs related to trap handling will be listed. Detailed introduction for CSR can be found in <a href="https://riscv.org/technical/specifications/" rel="external nofollow noopener" target="_blank">RISC-V Spec Volume 2</a>.</p> <p>Note that in RISC-V, each mode has its own set of CSRs (M: Machine; S: Supervisor; U: User/Application), and the bit width of CSR is determined by XLEN macro which has various configurations. <em>e.g. MEPC is for M-mode and SEPC is for S-mode. MXLEN for M-mode.</em></p> <p>CSRs relevant to trap handling in this post can be found at the end. Let’s trace through the handlers to see how RISC-V handling those unexpected events!</p> <h2 id="22-basic-trap-handling-process">2.2. Basic Trap Handling Process</h2> <p>In general, trap handling begins with its trap entry, which functions like an entrance to the “trap handling” park. The trap entry label is written in assembly code, while the handler is written in C. When the control is transfered to OS (ie. trap triggered), the program counter pointed to the address labeled <strong>trap entry</strong> in assembly.</p> <p><strong>Sample code for trap handler in machine mode</strong> is shown below^[3].</p> <p>RISC-V Assembly interrupt handler to Push and Pop register file</p> <pre><code class="language-assembly">  .align 2
  .global trap_entry
trap_entry:
  addi sp, sp, -16*REGBYTES
  //store ABI Caller Registers
  STORE x1, 0*REGBYTES(sp)
  STORE x5, 2*REGBYTES(sp)
    …
  STORE x30, 14*REGBYTES(sp)
  STORE x31, 15*REGBYTES(sp)
 //call C Code Handler
  call handle_trap
 //restore ABI Caller Registers
  LOAD x1, 0*REGBYTES(sp)
  LOAD x5, 2*REGBYTES(sp)
    …
  LOAD x30, 14*REGBYTES(sp)
  LOAD x31, 15*REGBYTES(sp)
  addi sp, sp, 16*REGBYTES
  mret
</code></pre> <p>C Code Handler determines interrupt cause and branches to the appropriate function</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">handle_trap</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mcause</span> <span class="o">=</span> <span class="n">read_csr</span><span class="p">(</span><span class="n">mcause</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mcause</span> <span class="o">&amp;</span> <span class="n">MCAUSE_INT</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//mask interrupt bit and branch to handler</span>
        <span class="n">isr_handler</span><span class="p">[</span><span class="n">mcause</span> <span class="o">&amp;</span> <span class="n">MCAUSE_CAUSE</span><span class="p">]</span> <span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">//branch to handler</span>
        <span class="n">exception_handler</span><span class="p">[</span><span class="n">mcause</span><span class="p">]();</span>
    <span class="p">}</span>
 <span class="p">}</span>
 <span class="c1">//write trap_entry address to mtvec  </span>
 <span class="n">write_csr</span><span class="p">(</span><span class="n">mtvec</span><span class="p">,</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">trap_entry</span><span class="p">));</span> 
</code></pre></div></div> <p>After getting to the “trap handling” park, to preserve user registers’ values before the content switching, they are stored into the kernel stack. After getting into the handle_trap() function in C, the cause of the trap is identified based on the value in CSR <strong>mcause</strong>. According to the type of cause, specific handler is called to further handle the trap. When the handler program is done, control is passed back to assembly side to restore the values in user registers. Finally, <strong>mret</strong> instruction is used to go back to user mode execution.</p> <p><img src="/images/trap_flow.png" alt="Trap Handling Flow"></p> <h2 id="23-variations">2.3. Variations</h2> <p>The description of the handling process above is pretty generic, and many detailed configurations of the process are varied. For instance, CSR <strong>mtvec</strong> is holding the base address of the trap entry and configuring the way to access trap handler. When it in direct mode (MODE 0), all exceptions set pc to BASE. When it is vectored mode (MODE 1), asynchronous interrupts set pc to BASE+4×cause. One more example, return instruction <strong>mret</strong> may not jump back to user mode, as it can also switch to another privileged mode based on configuration.</p> <p>Maybe I will further edit this post one day to introduce more about it or you can checkout those trap-related CSRs in <a href="https://riscv.org/technical/specifications/" rel="external nofollow noopener" target="_blank">RISC-V Spec Volume 2</a> to explore :D</p> <h2 id="24-relevant-csrs-list">2.4. Relevant CSRs List</h2> <ul> <li>Cause Register (<strong>mcause</strong>/<strong>scause</strong>): The highest bit (mcause[XLEN-1]) indicates this is caused by exception (0) or interrupt (1). The rest of bits (mcause[XLEN-2:0]) are holding the cause of the trap.</li> <li>Trap-Vector Base-Address Register (<strong>mtvec</strong>/<strong>stvec</strong>): read/write register that holds trap vector configuration, consisting of a vector base address (BASE) and a vector mode (MODE).</li> <li>Machine Exception Program Counter (<strong>mepc</strong>/<strong>sepc</strong>): Holds the address of the instruction which will be executed after current trap handling.</li> </ul> <h1 id="3-references"><strong>3. References</strong></h1> <p>[1] <a href="https://riscv.org/technical/specifications/" rel="external nofollow noopener" target="_blank">Volume 1/2, RISC-V Spec</a> [2] <a href="https://www.cs.sfu.ca/~ashriram/Courses/CS295/assets/books/HandP_RISCV.pdf" rel="external nofollow noopener" target="_blank">Computer Organization and Design - The Hardware/Software Interface: RISC-V Edition</a> [3] <a href="https://cdn2.hubspot.net/hubfs/3020607/An%20Introduction%20to%20the%20RISC-V%20Architecture.pdf" rel="external nofollow noopener" target="_blank">An Introduction to the RISC-V Architecture (Online Slides by SiFive) </a></p> <h1 id="4-helpful-links"><strong>4. Helpful Links</strong></h1> <p><a href="http://www.cs.cornell.edu/courses/cs316/2007fa/Lectures/Lec21_Interrupts_web.pdf" rel="external nofollow noopener" target="_blank">Cornell CompArch lecture slides</a> <a href="https://mullerlee.cyou/2020/07/09/riscv-exception-interrupt/" rel="external nofollow noopener" target="_blank">RISC-V Exception and Interrupt implementation (Blog by Lee)</a> <a href="https://www.sifive.com/blog/all-aboard-part-7-entering-and-exiting-the-linux-kernel-on-risc-v" rel="external nofollow noopener" target="_blank">All Aboard, Part 7: Entering and Exiting the Linux Kernel on RISC-V</a></p> </body></html>